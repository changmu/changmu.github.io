<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ERD</title>
    <url>/post/702c2c66.html</url>
    <content><![CDATA[<h2 id="ERD定义"><a href="#ERD定义" class="headerlink" title="ERD定义"></a>ERD定义</h2><p>ERD全称<code>Entity Relationship Diagrams</code>, 提供了表示存储结构的实体类型、属性和联系的方法，用来描述存储设计。</p>
<p>Markdown的mermaid插件提供了代码绘制ERD的功能，功能简洁，便于维护。</p>
<h2 id="ERD概念"><a href="#ERD概念" class="headerlink" title="ERD概念"></a>ERD概念</h2><p>ERD的概念很简单，只需要将实体和实体间的关系描述清楚即可</p>
<h3 id="实体Entity"><a href="#实体Entity" class="headerlink" title="实体Entity"></a>实体Entity</h3><p><code>实体(entity)</code> 表示一个存储的对象，使用长方形表现</p>
<pre class="mermaid">erDiagram
    Entity</pre>

<p>实体可以使用表格形式将其属性包含进来</p>
<pre class="mermaid">erDiagram
CAR {
    string allowedDriver FK "The license of the allowed driver"
    string registrationNumber
    string make
    string model
}</pre>

<h3 id="关联关系Relationship"><a href="#关联关系Relationship" class="headerlink" title="关联关系Relationship"></a>关联关系Relationship</h3><p>实体间的基本关联关系有以下3种</p>
<blockquote>
<p>1.一对一：对于实体集A与实体集B，A中的每一个实体至多与B中一个实体有关系；反之，在实体集B中的每个实体至多与实体集A中一个实体有关系。</p>
</blockquote>
<pre class="mermaid">erDiagram
    Citizen ||--|| IDnum: has</pre>
<blockquote>
<p>2.一对多：实体集A与实体集B中至少有N(N&gt;0)个实体有关系；并且实体集B中每一个实体至多与实体集A中一个实体有关系。</p>
</blockquote>
<pre class="mermaid">erDiagram
    Class ||--|{ Student: has</pre>
<blockquote>
<p>3.多对多：实体集A中的每一个实体与实体集B中至少有M(M&gt;0)个实体有关系，并且实体集B中的每一个实体与实体集A中的至少N（N&gt;0）个实体有关系。</p>
</blockquote>
<pre class="mermaid">erDiagram
    Student }o--|{ Course: elective</pre>

<h3 id="mermaid对ERD的支持"><a href="#mermaid对ERD的支持" class="headerlink" title="mermaid对ERD的支持"></a>mermaid对ERD的支持</h3><table>
<thead>
<tr>
<th align="center">ValueLeft</th>
<th align="center">ValueRight</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">|o</td>
<td align="center">o|</td>
<td align="center">0或1个</td>
</tr>
<tr>
<td align="center">||</td>
<td align="center">||</td>
<td align="center">1个</td>
</tr>
<tr>
<td align="center">}o</td>
<td align="center">o{</td>
<td align="center">0或多个</td>
</tr>
<tr>
<td align="center">}|</td>
<td align="center">|{</td>
<td align="center">1或多个</td>
</tr>
</tbody></table>
<h3 id="demo-app内测阶段激活码的ERD"><a href="#demo-app内测阶段激活码的ERD" class="headerlink" title="demo app内测阶段激活码的ERD"></a>demo app内测阶段激活码的ERD</h3><pre class="mermaid">erDiagram
Channel {
    int channel_id PK "渠道id"
    string name "渠道名"
}
InvitationCode {
    string code PK "邀请码"
    int channel_id FK "渠道id"
    int total "配额总个数"
    int used "已使用个数"
    int start_time "开始时间"
    int end_time "结束时间"
}
InvitationUser {
    string uid PK "被激活uid"
    string code "激活码"
    int ctime "激活时间"
}
Channel ||--o{ InvitationCode: has
InvitationCode ||--o{ InvitationUser: has</pre>
<h3 id="demo-常见视频app的ERD"><a href="#demo-常见视频app的ERD" class="headerlink" title="demo 常见视频app的ERD"></a>demo 常见视频app的ERD</h3><pre class="mermaid">erDiagram
User {
    string uid PK "用户唯一ID"
    string name
    string avatar
    int status "用户状态，封号注销等"
}
UserFollowed {
    string uid "用户uid"
    string followed_uid "被关注人uid"
    int follow_time "关注时间"
}
UserFans {
    string uid "用户uid"
    string fans_uid "粉丝uid"
    int follow_time "粉丝关注时间"
}
User ||--o{ UserFollowed: follow
User ||--o{ UserFans: be_followed


Feed {
    string feedid PK "视频唯一ID"
    string title
    string cover_url "封面图"
    string play_url "视频播放链接"
}
FeedComment {
    string comment_id
    string feedid
    string content
    string uid "评论人uid"
}
Feed ||--o{ FeedComment: post
User ||--o{ Feed: post

Msg {
    string msg_id PK
    string receiver_uid
    string sender_uid
    string content
}
User ||--o{ Msg: has</pre>

<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://www.smartdraw.com/entity-relationship-diagram/">ERD介绍</a></p>
<p><a href="https://mermaid-js.github.io/mermaid/#/entityRelationshipDiagram">mermaid官方手册</a></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>ERD</tag>
      </tags>
  </entry>
  <entry>
    <title>golang code snippet</title>
    <url>/post/cee729f9.html</url>
    <content><![CDATA[<h2 id="列表去重"><a href="#列表去重" class="headerlink" title="列表去重"></a>列表去重</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RmDupAndEmptyOfList 列表元素去重并去空</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RmDupAndEmptyOfList</span><span class="params">(list []<span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">	mp := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, item := <span class="keyword">range</span> list &#123;</span><br><span class="line">		<span class="keyword">if</span> item != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			mp[item] = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> listUniq []<span class="type">string</span></span><br><span class="line">	<span class="keyword">for</span> k := <span class="keyword">range</span> mp &#123;</span><br><span class="line">		listUniq = <span class="built_in">append</span>(listUniq, k)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> listUniq</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并发处理任务"><a href="#并发处理任务" class="headerlink" title="并发处理任务"></a>并发处理任务</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GoAndWait 封装更安全的多并发调用, 启动goroutine并等待所有处理流程完成，自动recover</span></span><br><span class="line"><span class="comment">// 返回值error返回的是多并发协程里面第一个返回的不为nil的error，主要用于关键路径判断，当多并发协程里面有一个是关键路径且有失败则返回err，其他非关键路径并发全部返回nil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GoAndWait</span><span class="params">(handlers ...<span class="keyword">func</span>()</span></span> <span class="type">error</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		wg   sync.WaitGroup</span><br><span class="line">		once sync.Once</span><br><span class="line">		err  <span class="type">error</span></span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> handlers &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(handler <span class="keyword">func</span>()</span></span> <span class="type">error</span>) &#123;</span><br><span class="line">			<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				<span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> &#123;</span><br><span class="line">					buf := <span class="built_in">make</span>([]<span class="type">byte</span>, PanicBufLen)</span><br><span class="line">					buf = buf[:runtime.Stack(buf, <span class="literal">false</span>)]</span><br><span class="line">					log.Errorf(<span class="string">&quot;[PANIC]%v\n%s\n&quot;</span>, e, buf)</span><br><span class="line">					once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">						err = errs.New(errs.RetServerSystemErr, <span class="string">&quot;panic found in call handlers&quot;</span>)</span><br><span class="line">					&#125;)</span><br><span class="line">				&#125;</span><br><span class="line">				wg.Done()</span><br><span class="line">			&#125;()</span><br><span class="line">			<span class="keyword">if</span> e := handler(); e != <span class="literal">nil</span> &#123;</span><br><span class="line">				once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">					err = e</span><br><span class="line">				&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(f)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/post/4a17b156.html</url>
    <content><![CDATA[<p>用来测试相关特性</p>
<h1 id="测试代码块"><a href="#测试代码块" class="headerlink" title="测试代码块"></a>测试代码块</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getFreeAddr</span><span class="params">()</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	tmpAddr, err := net.ResolveTCPAddr(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:0&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	l, err := net.ListenTCP(<span class="string">&quot;tcp&quot;</span>, tmpAddr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = l.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> l.Addr().String(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="测试专用语法代码块"><a href="#测试专用语法代码块" class="headerlink" title="测试专用语法代码块"></a>测试专用语法代码块</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alert(&#x27;Hello World!&#x27;);</span><br></pre></td></tr></table></figure>

<span id="more"></span>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2>]]></content>
      <categories>
        <category>备忘录</category>
      </categories>
  </entry>
  <entry>
    <title>论寅巳申三刑</title>
    <url>/post/ee408ec8.html</url>
    <content><![CDATA[<p>正在亲身体验寅巳申三刑<code>壬寅年乙巳月 2022.05.05 -- 2022.06.06</code>, 等6.6过后我再总结下相关案例和自己的体验</p>
<span id="more"></span>

<p>TODO</p>
]]></content>
      <categories>
        <category>易经</category>
        <category>子平</category>
      </categories>
  </entry>
  <entry>
    <title>论用神</title>
    <url>/post/935779c7.html</url>
    <content><![CDATA[<p>用神，就是对命主有好处的干支，能雪中送炭，能锦上添花。</p>
<span id="more"></span>
<p>用神可以分成下面四类</p>
<ul>
<li>扶抑用神</li>
<li>格局用神</li>
<li>调候用神</li>
<li>通关用神</li>
</ul>
<h2 id="扶抑用神"><a href="#扶抑用神" class="headerlink" title="扶抑用神"></a>扶抑用神</h2><p>这也是目前最流行的一种用神定位方式，以追求日元平衡为目标。先看日主强弱，综合全盘衡量自党异党力量对比，日元强则喜克泄耗，弱则喜扶助。</p>
<p>TODO</p>
]]></content>
      <categories>
        <category>易经</category>
        <category>子平</category>
      </categories>
  </entry>
  <entry>
    <title>论驿马</title>
    <url>/post/53de3820.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>易经</category>
        <category>子平</category>
      </categories>
  </entry>
  <entry>
    <title>golang知识点总结</title>
    <url>/post/393519b.html</url>
    <content><![CDATA[<h1 id="GMP调度器"><a href="#GMP调度器" class="headerlink" title="GMP调度器"></a>GMP调度器</h1><p>linux默认线程大小是8MB(默认栈大小)<br>goroutine大小是8KB左右</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://learnku.com/articles/41728">Golang 调度器 GMP 原理与调度全分析</a></li>
<li><a href="https://www.yuque.com/aceld/golang/ithv8f">Golang修养之路</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
        <category>golang</category>
      </categories>
  </entry>
</search>
